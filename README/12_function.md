# 함수
- 프로그래밍 언어의 함수는 인련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 매개변수 : 함수 내부로 입력을 전달받는 변수
- 입력 : 인수
- 출력 : 반환값

<img src = "../img/chap12_1.jpg">

- 함수는 함수 정의를 통해 생성한다. 자바스크립트는 다양한 방법으로 정의 할 수있다.

1. 함수 선언문

```javascript
// 함수 정의
function add(x, y){
  return x + y
}
```

- 함수 정의만으로 함수가 실행되는 것은 아니다. 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시해야한다 이를 함수 호출이라 한다.

```javascript
// 함수 호출
var result = add(2, 5)
console.log(result)
console.log(add(2, 5))
```

## 함수를 사용하는 이유
- 함수는 필요할 때 여러 번 호출할 수 있다. 즉, 실행 시점을 개발자가 결정할 수 있고 몇 번이든 재사용이 가능하다.
- 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용이라는 측면에서 매우 유용하다.

## 함수 리터럴

- 함수 리터럴의 구성요소는 다음과 같다.

<img src = "../img/chap12_2.jpg">


## 함수 정의
- 함수 정의란 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말하며 함수를 정의하는 방법에는 4가지가 있다.

- Tip : 변수 선언과 함수 정의
  - 변수는 선언한다고 했지만 함수는 정의한다고 표현했다. 함수 선언문이 평가되면 암묵적으로 생성되고 함수 객체가 할당된다

<img src = "../img/chap12_3.jpg">

## 함수 선언문

```javascript
// 함수 선언문
function add(x, y){
  return x + y;
}

// console.dir은 함수 객체의 프로퍼티까지 출력한다.
// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.
console.dir(add) // f add(x,y)

// 함수 호출
console.log(add(2, 5)) // 7
```

- 함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다.

- 함수 선언문은 표현식이 아닌 문이다.  
- 하지만 전에 배웠던 내용에서 표현식이 아닌 문은 특정 변수에 값으로 할당되지 못한다고 했는데 함수 선언문은 특정 변수에 값으로 할당 될 수있다.
- 이 이유는 자바스크립트 엔진이 코드의 문맥에 따라 해석을 달리하기 때문이다.
- 코드블록의 `{}`와 객체 `{}`리터럴이 같지만 코드의 문맥에 따라 다르게 해석되는걸 생각하면 된다.

```javascript
// 함수 선언문
function foo() { console.log('foo'); };
foo() // foo

// 함수 리터럴
(function bar() { console.log('bar'); });
bar() // ReferenceError
```
- 위 코드의 단독으로 사용된 함수 리터럴은 함수 선언문으로 해석된다. 
- 하지만 그룹 연산자 `()` 내에 있는 함수리터를은 함수 선언문으로 해석되지 않고 함수 리터럴 표현식으로 해석된다.
- 그룹 연산자의 피연산자는 값으로 평가될 수 있는 표현식이어야 한다. 따라서 표현식이 아닌 문인 함수 선언문은 피연산자로 사용할 수 없기 때문에 리터럴로 해석되는 것이다.
- 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다. 함수 이름이 메모리 주소를 가르킨다고 오해하면 안된다.

<img src = "../img/chap12_4.jpg">

- bar 함수는 `()` 그룹연산자의 피연산자로 판별되 값으로 평가되었으며, 위 그림처럼 함수를 가리키는 식별자가 없기 때문에 bar 함수는 호출할 수 없다.

<img src = "../img/chap12_5.jpg">

- 그럼 foo함수는 어떻게 어떻게 호출될 수 있을까 foo 또한 함수 몸체 내부에서만 유요한 식별자인 함수이름만 있기 때문에 호출 할수 없어야 한다. 하지만 foo는 자바스크립트 엔진이 암묵적으로 생성한 식별자가 되었다. 자바스크립트 엔진은 함수 선언문으로 해석되면 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당하게 되어 foo를 호출 할수 있는 것이다.

<img src = "../img/chap12_5.jpg">

- 결국 위 그림과 같이 함수 선언문 으로 판별되면 var add를 선언하지 않아도 암묵적으로 생성되는 것이다.
- 함수는 함수이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.

## 함수 표현식
- 함수는 객체 타입의 값으므로 함수는 값처럼 변수에 할당 할 수도있고 프로퍼티 값이 될 수도 있으며, 배열의 요소가 될 수도 있다 이처럼 값의 성질을 갖는 객체를 일급 객체라고한다.

```javascript
// 함수 표현식
var add = function (x, y){
  return x + y;
};

console.log(add(2, 5)) // 7
```

- 위 코드는 함수 표현식이다. 함수 선언문에 식별자가 없으면 함수 표현식이 되는것이다. 그렇다고 함수 선언문과 함수 표현식이 정확히 동일하게 동작하는 것은 아니다.
- 함수 리터럴의 함수 이름은 생략할 수 있는데 이러한 함수를 익명함수라 한다. 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.
- 함수 이름은 함수 몸체 내부에서만 유요한 식별자이므로 함수 이름은 함수를 호출할 수 없다
- 함수 선언문의 함수 이름으로 식별자를 암묵적 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보이지만 함수 선언문은 "표현식이 아닌 문"이고 함수 표현식은 "표현식인 문"이다. 미묘하지만 중요한 차이가 있다.

- 정리 
  - 값(피 연산자)이 되면 함수 리터럴
  - 표현식이 아닌 문이면 함수 선언문(함수 이름만 선언되있을 시)
  - 표현식인 문이되면 함수 표현식(변수에 할당되면)

